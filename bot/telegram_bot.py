import logging
import time
import os
from io import BytesIO
from datetime import datetime

from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    BotCommand,
    InputFile
)
from telegram.constants import ChatAction, ParseMode
from telegram.ext import (
    ContextTypes,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters
)

from .dialog_manager import DialogManager
from .openai_helper import OpenAIHelper
from .knowledge_base.indexer import KnowledgeBaseIndexer
from .knowledge_base.retriever import KnowledgeBaseRetriever

logger = logging.getLogger(__name__)


class ChatGPTTelegramBot:
    def __init__(self, settings):
        self.settings = settings
        self.dialog_manager = DialogManager()
        self.openai = OpenAIHelper(
            api_key=settings.openai_api_key,
            model=settings.openai_model,
            image_model=settings.image_model
        )
        self.kb_indexer = KnowledgeBaseIndexer(settings)
        self.kb_retriever = KnowledgeBaseRetriever(settings)

        self.current_dialog_by_user = {}
        self.awaiting_rename = {}
        self.awaiting_kb_pwd = {}

    async def cmd_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç! –Ø –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ.")

    async def cmd_help(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text("–°–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥: /dialogs /rename /export /kb /kb_diag /model /mode /img /web /stats")

    async def cmd_dialogs(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        dialogs = self.dialog_manager.get_active_dialogs(user_id)

        buttons = []
        for dlg in dialogs:
            title = f"{dlg.title} | {dlg.created_at.strftime('%Y.%m.%d')}"
            buttons.append([
                InlineKeyboardButton(title, callback_data=f"dlg:open:{dlg.id}"),
                InlineKeyboardButton("‚úèÔ∏è", callback_data=f"dlg:rename:{dlg.id}"),
                InlineKeyboardButton("üì§", callback_data=f"dlg:export:{dlg.id}"),
                InlineKeyboardButton("üóëÔ∏è", callback_data=f"dlg:del:{dlg.id}")
            ])
        buttons.append([InlineKeyboardButton("‚ûï –ù–æ–≤—ã–π –¥–∏–∞–ª–æ–≥", callback_data="dlg:new")])

        await update.message.reply_text(
            "–í–∞—à–∏ –¥–∏–∞–ª–æ–≥–∏:",
            reply_markup=InlineKeyboardMarkup(buttons)
        )

    async def cmd_rename(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        current_dlg = self.current_dialog_by_user.get(user_id)
        if not current_dlg:
            await update.message.reply_text("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞.")
            return
        self.awaiting_rename[user_id] = current_dlg
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–∏–∞–ª–æ–≥–∞:")

    async def cmd_export(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        current_dlg = self.current_dialog_by_user.get(user_id)
        if not current_dlg:
            await update.message.reply_text("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞.")
            return
        md_text = self.dialog_manager.export_dialog(current_dlg, user_id)
        if not md_text:
            await update.message.reply_text("–î–∏–∞–ª–æ–≥ –ø—É—Å—Ç.")
            return
        file_bytes = BytesIO(md_text.encode("utf-8"))
        file_bytes.name = f"dialog_{current_dlg}.md"
        await update.message.reply_document(InputFile(file_bytes))

    async def cmd_kb_diag(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        current_dlg = self.current_dialog_by_user.get(user_id)
        if not current_dlg:
            await update.message.reply_text("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞.")
            return
        dlg = self.dialog_manager.get_dialog(current_dlg, user_id)
        msgs = self.dialog_manager.get_messages(current_dlg, limit=5)
        kb_docs = dlg.kb_documents if hasattr(dlg, "kb_documents") else []

        text = f"–î–∏–∞–ª–æ–≥: {dlg.title} (ID {dlg.id})\n–í—ã–±—Ä–∞–Ω–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã: {', '.join(kb_docs) or '‚Äî'}\n–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è:\n"
        for m in reversed(msgs):
            text += f"[{m.role}] {m.content}\n"
        await update.message.reply_text(text)

    async def on_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        data = query.data
        user_id = update.effective_user.id

        if data == "dlg:new":
            dlg = self.dialog_manager.create_dialog(user_id)
            self.current_dialog_by_user[user_id] = dlg.id
            await query.edit_message_text(f"–°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥: {dlg.title}")
            return

        if data.startswith("dlg:open:"):
            dlg_id = int(data.split(":")[2])
            self.current_dialog_by_user[user_id] = dlg_id
            dlg = self.dialog_manager.get_dialog(dlg_id, user_id)
            last_msg = self.dialog_manager.get_messages(dlg_id, limit=1)
            last_date = last_msg[0].timestamp.strftime("%Y.%m.%d") if last_msg else "‚Äî"
            await query.edit_message_text(f"üìÇ –î–∏–∞–ª–æ–≥ '{dlg.title}' (–ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: {last_date}) –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.")
            return

        if data.startswith("dlg:rename:"):
            dlg_id = int(data.split(":")[2])
            self.awaiting_rename[user_id] = dlg_id
            await query.edit_message_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–∏–∞–ª–æ–≥–∞:")
            return

        if data.startswith("dlg:export:"):
            dlg_id = int(data.split(":")[2])
            md_text = self.dialog_manager.export_dialog(dlg_id, user_id)
            if not md_text:
                await query.edit_message_text("–î–∏–∞–ª–æ–≥ –ø—É—Å—Ç.")
                return
            file_bytes = BytesIO(md_text.encode("utf-8"))
            file_bytes.name = f"dialog_{dlg_id}.md"
            await context.bot.send_document(chat_id=user_id, document=InputFile(file_bytes))
            return

        if data.startswith("dlg:del:"):
            dlg_id = int(data.split(":")[2])
            self.dialog_manager.soft_delete_dialog(dlg_id, user_id)
            await query.edit_message_text("–î–∏–∞–ª–æ–≥ —É–¥–∞–ª—ë–Ω.")
            return

        if data.startswith("kb:pwd:"):
            idx = int(data.split(":")[2])
            self.awaiting_kb_pwd[user_id] = idx
            await query.edit_message_text("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É:")
            return

    async def on_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        text = update.message.text.strip()

        if user_id in self.awaiting_rename:
            dlg_id = self.awaiting_rename.pop(user_id)
            self.dialog_manager.rename_dialog(dlg_id, user_id, text)
            await update.message.reply_text(f"–î–∏–∞–ª–æ–≥ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω –≤: {text}")
            return

        if user_id in self.awaiting_kb_pwd:
            idx = self.awaiting_kb_pwd.pop(user_id)
            # –ó–¥–µ—Å—å –ª–æ–≥–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–∞—Ä–æ–ª—è
            await update.message.reply_text("üîë –ü–∞—Ä–æ–ª—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω.")
            return

        current_dlg = self.current_dialog_by_user.get(user_id)
        if not current_dlg:
            dlg = self.dialog_manager.create_dialog(user_id)
            self.current_dialog_by_user[user_id] = dlg.id
            current_dlg = dlg.id

        self.dialog_manager.add_message(current_dlg, "user", text)
        kb_ctx = None
        dlg_obj = self.dialog_manager.get_dialog(current_dlg, user_id)

        reply = await self.openai.chat(
            dialog_id=current_dlg,
            user_id=user_id,
            user_message=text,
            style=dlg_obj.style,
            kb_context=kb_ctx,
            model=dlg_obj.model
        )

        self.dialog_manager.add_message(current_dlg, "assistant", reply)
        await update.message.reply_text(reply)
